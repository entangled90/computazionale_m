#include <stdio.h>
#include <stdlib.h>


<<<<<<< HEAD
struct Spin {
	unsigned int i,j;
	unsigned int spin;
	int index;
};

struct SpinNode{
	struct Spin * node;
	struct Spin * next;
	struct Cluster * node_cluster;
};

struct Cluster{
	struct Node * head;-
};

struct ClusterNode{
	struct Cluster * node;
	struct Cluster * next;
};

struct ClusterList{
	struct ClusterNode * head;
};


typedef struct Spin Spin;
typedef struct Node Node;
typedef struct Cluster Cluster;
typedef struct ClusterNode ClusterNode;
typedef struct ClusterList ClusterList;

ClusterList * initClusterList (Cluster * c ){
	ClusterList * c_list = (ClusterList *) malloc(sizeof(ClusterList));
	ClusterNode * c_node = (ClusterNode * )malloc(sizeof(ClusterNode));
	c_list->head = c_node;
	c_node->node= &c;
	c_node->next = NULL;
	cluster_t->head = node_t;
	return cluster;
}

void deleteClusterList( ClusterList * head){
	ClusterNode ** temp = &(head->head);
	while (temp){
		free(*temp);
		temp = &((*temp)->next);
	}
	free(head);
}
void addClusterNode (ClusterNode * c_node, ClusterList * c_list){
	ClusterNode * temp = c_list->head;
	while(temp->next){
		temp = temp->next;
	}
	temp->next = c_node;
	c_node->next = NULL;
}

Cluster * initCluster (Node * s ){
	cluster_t = malloc(sizeof(Cluster));
	s->next = NULL;
	s->node_cluster = cluster_t;
	cluster_t->head = s;
	return cluster;
}

/* n_after è l'elemento dopo il quale si aggiunge n_new */
void addNodeAfterElement(Node * n_new, Node * n_after){
	n_new->next = n_after->next;
	n_after->next = n_new;
	n_new->node_t = n_after->node_cluster;
}

/* n_del va tolto dalla lista 
 0- elemento trovato
 1 - elemnto non trovat
 */
void deleteNode(Node * n_del){
	Node * temp = n_del->node_cluster;
	if ( temp == n_del){
		c->head = n_del->next;
		n_del->next = NULL;
	}
	else{
		while (temp->next != n_del !! temp->next == NULL){
			temp = temp->next;
		}
		if(temp->next != NULL){
			temp->next = n_del->next;
			n_del = NULL;
		}
	}
}
=======
struct spin {
	unsigned int i,j;
	unsigned int spin;
	int index;
	struct spin * next;
	struct spin * prev;
};



typedef struct spin spin;


// potrebbe servire la lunghezza della lista

void listInit( spin * s , int n){
	int i;
	for ( i = 0 ; i< n; i++){
		s[i].next = s + (i+1)%n;
		s[i].prev = s + (i-1)%n;
	}
}


/* s_new già allocato! s_new viene messo dopo s_old! */
void extend( spin * s_old , spin * s_new ){
	s_new->next = s_old->next;
	s_new->prev = s_old;
	s_old-> next = s_new;
}

/* head sono i puntatori all'inizio delle liste (che concettualmente non ci sono visto che le liste son periodiche)
	ma facendo head.prev ottieni la coda automaticamente.
	Nella memoria le liste son periodiche, nell'utilizzo possono essere utilizzate come orientate!
  attacco la testa della seconda lista alla coda della prima.
*/
void joinList ( spin * head1, spin * head2){
	spin * temp;
	spin * temp2;
	temp = head1->prev; // tail1
	temp2 = head2->prev;
	temp2->next = head1;
	head1->prev = temp2; // nuovo tail1 è tail2
 	head2->prev = temp; //nuovo tail2 è tail1
	temp->next = head2;
}

void flowList ( spin * start, spin * stop ) {
	spin * temp;
	temp = start;
	while ( temp->next != stop){
		printf("prev:%d\t indice: %d\t next:%d\n", temp->prev->index,temp->index,temp->next->index);
		temp = temp->next;
	}
	printf("indece del prossimo è: %d\n", temp->next->index);
}
>>>>>>> 7829c86140295884ef04229d07375f4b7f888534
